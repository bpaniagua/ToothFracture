#!/usr/bin/env python

import csv
import sys
import numpy as np
import matplotlib.pyplot as plt
from blagging import *

from sklearn import svm, datasets
from sklearn.cross_validation import KFold, StratifiedKFold, cross_val_score
from sklearn.metrics import auc, roc_auc_score, roc_curve, precision_recall_curve
from sklearn.decomposition import PCA
from scipy import interp

'''
This script runs creates a balanced Bagging ensemble classifier using SVM, and plots a KFold-cross validation
mean ROC curve

The synthetic tooth fracture data was imbalanced (6 healthy, 36 unhealthy) as of 4/4/2017,
and hence a balanced bagging approach was used.

The balanced bagging class "BlaggingClassifier" lives in blagging.py

Dependencies for this script to run: scikit-learn, numpy, scipy and matplotlib

The input parameters:
 - A path to a csv file that is generated by ToothFractureStatistics Slicer extension.
 The CSV file will have class labels in the 3rd column, and wavelet responses in the columns after that.
 A header row is assumed to be present
 - 0-indexed column number with class labels
 - A string indicating positive class label
 - 0-indexed column number of data beginning
 - 0-indexed column number of data end.

Examples:
ToothFractureROCAnalysis.py /path/to/ToothFractureAnalysis.csv 2 'Fractured' 3 6
- The classification labels are in column 2 (O-indexed)
- The positive class label for binary classification is 'Fractured'
- Data will be formed from columns 3-6 (0-indexed)

'''

def plot_ROC_curve(classifier, X, y, pos_label=1, n_folds=3):
    mean_tpr = 0.0
    mean_fpr = np.linspace(0, 1, 100)
    all_tpr = []
    plt.subplot(1, 2, 1)
    # Create ROC Curves using KFold - cross validation.
    for i, (train, test) in enumerate(StratifiedKFold(y, n_folds=n_folds)):
        print 'Running fold ', i
        probas_ = classifier.fit(X[train], y[train]).predict_proba(X[test])
        print 'Number of positive labels in training: ', np.sum(y[train]), ' Number of negative lables in training: ', y[train].shape[0]-np.sum(y[train])
        # Compute ROC curve and area under the curve
        fpr, tpr, thresholds = roc_curve(y[test], probas_[:, 1], pos_label=1)
        mean_tpr += interp(mean_fpr, fpr, tpr)
        mean_tpr[0] = 0.0
        roc_auc = auc(fpr, tpr)
        print 'AUC for fold ', i, ' ROC ', roc_auc
        # Plot individual ROC curve
        #plt.plot(fpr, tpr, lw=1, label='ROC fold %d (area = %0.2f)' % (i, roc_auc))
    # Plot the center line
    plt.plot([0, 1], [0, 1], '--', color=(0.6, 0.6, 0.6), label='Midline')
    mean_tpr /= n_folds
    mean_tpr[-1] = 1.0
    mean_auc = auc(mean_fpr, mean_tpr)
    # Plot the mean ROC curve
    plt.plot(mean_fpr, mean_tpr, 'k--',
         label='Mean ROC (area = %0.2f)' % mean_auc, lw=2)
    plt.xlim([-0.05, 1.05])
    plt.ylim([-0.05, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver operating characteristic')
    plt.legend(loc="lower right")


############ ENTRY POINT OF THE SCRIPT ################
if len(sys.argv) != 6:
  print "Usage: " + sys.argv[0] + " inputCSVFile classLabelColumn positiveClassName dataColumnMin dataColumnMax"
  sys.exit(1)

# Read in the csv file
filepath  = sys.argv[1]
with open(filepath, 'r') as f:
    reader = csv.reader(f)
    data = list(reader)

classLabelColumn = int(sys.argv[2])
dataColumnMin = int(sys.argv[4])
dataColumnMax = int(sys.argv[5])
positiveClassName = sys.argv[3]

# Get the class names
list1 = [classLabelColumn]
Y = [[each_list[i] for i in list1] for each_list in data]
Y.pop(0)
# Create a binary label array to be passed to the classifiers.
y = np.array([ (1 if val[0] == positiveClassName else 0) for val in Y])


# Get the wavelet response values.
list1 = range(dataColumnMin,dataColumnMax+1)
x = [[each_list[i] for i in list1] for each_list in data]
x.pop(0)

X = np.asarray(x)
print 'Found ', X.shape[0], ' data points with ', X.shape[1], ' features'

plt.figure()
plt.title('Synthetic Tooth Fracture detection')

# setup an SVM classifier
classifier = svm.SVC(kernel='linear', probability=True, C = 0.5)
# Create ROC using balanced bagging classifier
plot_ROC_curve(BlaggingClassifier(base_estimator=classifier, n_estimators=5), X, y)

# Plot PCA's first two components to look at the data discrimination.
pca = PCA(n_components=2)
pcaX = pca.fit_transform(X)
zero_class = np.where(y == 0)
one_class = np.where(y == 1)
plt.subplot(1, 2, 2)
plt.scatter(pcaX[zero_class, 0], pcaX[zero_class, 1], s=160, edgecolors='b',
            facecolors='none', linewidths=2, label='Not Fractured')
plt.scatter(pcaX[one_class, 0], pcaX[one_class, 1], s=80, edgecolors='orange',
            facecolors='none', linewidths=2, label='Fractured')
plt.xlabel('PCA first component')
plt.ylabel('PCA second component')
plt.show()